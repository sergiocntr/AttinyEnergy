/*Example #2 code:
assumes a clock speed of 8MHz on an ATtiny85
uses 10-bit resolution (values from 0-1024)
uses ADC1 on pin PB2
uses internal 1.1V as the reference voltage
*/
#include "TinyWireS.h"
//TinyDebugSerial mySerial= TinyDebugSerial();
#define I2C_SLAVE_ADDRESS 0x02 // the 7-bit address (remember to change this when adapting this example)
// I2C
//attiny pin 0 = not(OC1A) = PORTB <- _BV(0) = SOIC pin 5 (I2C SDA, PWM)
//attiny pin 2 =           = PORTB <- _BV(2) = SOIC pin 7 (I2C SCL, Analog 1)
// The default buffer size, Can't recall the scope of defines right now
#ifndef TWI_RX_BUFFER_SIZE
#define TWI_RX_BUFFER_SIZE ( 16 )
#endif
#include <Arduino.h>
#define emonTxV3  //per 3.3volt
void initADC()
{

  /* this function initialises the ADC

  For more information, see table 17.5 "ADC Prescaler Selections" in
  chapter 17.13.2 "ADCSRA – ADC Control and Status Register A"
  (pages 140 and 141 on the complete ATtiny25/45/85 datasheet, Rev. 2586M–AVR–07/10)


  // 10-bit resolution
  // set ADLAR to 0 to disable left-shifting the result (bits ADC9 + ADC8 are in ADC[H/L] and
  // bits ADC7..ADC0 are in ADC[H/L])
  // use uint16_t variable to read ADC (intead of ADCH or ADCL)

  */

  ADMUX =
	    (0 << ADLAR) |     // do not left shift result (for 10-bit values)
            (0 << REFS2) |     // Sets ref. voltage to internal 1.1V, bit 2
            (1 << REFS1) |     // Sets ref. voltage to internal 1.1V, bit 1
            (0 << REFS0) |     // Sets ref. voltage to internal 1.1V, bit 0
            (0 << MUX3)  |     // use ADC1 for input (PB2), MUX bit 3
            (0 << MUX2)  |     // use ADC1 for input (PB2), MUX bit 2
            (0 << MUX1)  |     // use ADC1 for input (PB2), MUX bit 1
            (1 << MUX0);       // use ADC1 for input (PB2), MUX bit 0

  ADCSRA =
            (1 << ADEN)  |     // Enable ADC
            (1 << ADPS2) |     // set prescaler to 128, bit 2
            (1 << ADPS1) |     // set prescaler to 128, bit 1
            (1 << ADPS0);      // set prescaler to 128, bit 0
}

uint16_t readADC()
{


    ADCSRA |= (1 << ADSC);         // start ADC measurement
    while (ADCSRA & (1 << ADSC) ); // wait till conversion complete

    // for 10-bit resolution:
    //adc_lobyte = ADCL; // get the sample value from ADCL
    //raw_adc = ADCH<<8 | adc_lobyte;   // add lobyte and hibyte
    return ADCW;
    //if (raw_adc > 512)
    //{
      // ADC input voltage is more than half of the internal 1.1V reference voltage

    }// else {

      // ADC input voltage is less than half of the internal 1.1V reference voltage

    //}

  //}

  //return 0;
}
void setup(){
  initADC();
  TinyWireS.begin(I2C_SLAVE_ADDRESS);
  TinyWireS.onReceive(receiveEvent);
  TinyWireS.onRequest(requestEvent);
}
void loop(){

}
void requestEvent()
{
  TinyWireS.send(cv.dati[reg_position]);
  // Increment the reg position on each read, and loop back to zero
  reg_position++;
  TinyWireS.send(cv.dati[reg_position]);
  if (reg_position >= reg_size)
  {
    reg_position = 0;
  }
}
void receiveEvent(uint8_t howMany)
{
    if (howMany < 1)
    {
        // Sanity-check
        return;
    }
    if (howMany > TWI_RX_BUFFER_SIZE)
    {
        // Also insane number
        return;
    }
    reg_position = TinyWireS.receive();
    if(reg_position == 20) powerDownEsp();
}
